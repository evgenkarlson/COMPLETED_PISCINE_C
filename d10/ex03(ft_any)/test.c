/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/05/12 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/09/28 19:28:33 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*         команда для компиляции и одновременного запуска                    */
/*                                                                            */
/*  gcc -Wall -Werror -Wextra test.c && chmod +x ./a.out && ./a.out           */
/* ************************************************************************** */

#include <unistd.h>				/* Подключаем библиотеку содержащую функцию "write" */

/* ************************************************************************** */
void		ft_putchar(char c)	/* Функция печати символа */
{
	write(1, &c, 1);
}

/* ************************************************************************** */

void		ft_putstr(char *str)/* Функция печати строки */
{
	while(*str)
		ft_putchar(*str++);
}

/* ************************************************************************** */

int		ft_find_separator(char *str) /* Функция ищет в строке непечатаемые символы или символы пробела */
{
	int i;
	int boolean;

	i = 0;
	boolean = 0;
	while (str[i])
	{
		if (str[i] < '!')
			boolean = 1;
		i++;
	}
	return (boolean);
}

/* ************************************************************************** */

int	ft_any(char **tab, int(*f)(char*))	/* Функция будет возвращать 1, если, переданный функции "f",
 								 * хотя бы один элемент массива возвращает 1. Иначе функция вернет 0. */
{
	int	i;						/* Обьявляем переменную для счетчика */

	i = 0;						/* Инициализируем счечик нулем */
	while (tab[i])				/* Запускаем цикл кооторый пройдет по каждой строке массива строк */
	{
		if (f(tab[i]) == 1)		/* Отправляем адресс текущей строки в функцию. Если результат работы функции над текущей строкой равен 1*/
			return (1);			/* То завершаем функцию и возвращаем 1*/
		i++;					/* Увеличиваем счетчик для прехода к след строке */
	}
	return (0);					/* Если дошли до сюда значит функция 'f' в каждой из строк не нашла ничего что бы заставило ее вернуть 1.
								 * ПО этому мы завершаем функцию и возвращаем 0 */
}


int 		main(void)
{
	/* Создадим несколько строк для теста и сохраним их адреса в массиве указателей */
	char *arr[4] = {"HolaHolaLalala_ksijrnfejrn", \
					"jyawgvefiueomwearawefwefwefwefweef", \
					"sfds jkljsda kjl sfd sdf sdfsdfd sdfsdfsdf"};
	/* Отправим адресс массива указателей с адресами наших строк(массивов символов) в функцию и отправим в функцию адрес функции 'ft_find_separator' */
	if(ft_any(arr, &ft_find_separator))	/* Если результат функции 'ft_any' будет больше нуля */
		ft_putstr("TRUE\n");			/* Тогда печатаем эту строку */
	else
		ft_putstr("FALSE\n");			/* Иначе  печатаем эту строку */

    return (0);						/* Возвращаем 0 и завершаем программу */
}