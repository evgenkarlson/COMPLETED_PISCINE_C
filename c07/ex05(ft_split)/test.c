/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/11/29 01:11:31 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*         команда для компиляции и одновременного запуска                    */
/*                                                                            */
/*  gcc -Wall -Werror -Wextra test.c && chmod +x ./a.out && ./a.out           */
/* ************************************************************************** */


#include <unistd.h>						/* Подкоючаем библиотеку содержащую функцию для вывода символов(write) */
#include <stdlib.h>						/* Подкоючаем библиотеку содержащую функцию для выделения памяти(malloc) 
										** и функцию для подсчета размера переменной(sizeof) */

/* ************************************************************************** */
/* ************************************************************************** */

void	ft_putchar(char c)				/* функция вывода символа */
{
	write(1, &c, 1);
}

/* ************************************************************************** */
/* ************************************************************************** */

void	ft_putstr(char *str)   			/* Функция печати строки */
{
	while(*str)
		ft_putchar(*str++);
}

/* ************************************************************************** */
/* ************************************************************************** */

int		ft_is_space(char to_find, char *str)/* Функция ищет символ в строке */
{
	while (*str)
	{
		if (to_find == *str++)
			return (1);
	}
	return (0);
}

/* ************************************************************************** */
/* ************************************************************************** */

int		ft_wordcount(char *str, char *charset)/* Функция считает количество слов по выбранным нами разделителям */
{
	int		count;						/* Обьявляем счетчик количества найденых слов */

	count = 0;							/* Инициализируем счетчик нулем */
	while (*str)
	{
		while (*str && ft_is_space(*str, charset))/* Если текущий символ из строки "str", относится к тем что выбраны
										** как разделители слов в строке "spacechar", значит этот символ часть пространства
										** между словами */
			str++;
		if (*str && !(ft_is_space(*str, charset)))
		{								/* Если текущий симовол из ячейки "str" не нашелся в строке "spacechar" значит он
										** является частью слова */
			count++;					/* И мы прибавляем 1 к счетчику количества найденых слов */
			while (*str && !(ft_is_space(*str, charset)))/* Если последующие символы это не разделители, значит они
										** являются частью того же самого текущего слова */
				str++;					/* Если ячейка не является концом то проверяем есть ли дальше в str такие же 
										** символы как и в to_find. Увеличиваем счетчик j указывая на след ячейку 
										** массива str и след ячейку массива spacechar и проверяем их */
		}
	}
	return (count);						/* Возвращаем количество найденых слов и завершаем функцию */
}

/* ************************************************************************** */
/* ************************************************************************** */

char	*create_word(char *str, int i, int j)	/* Функция принимает строку и диапазон символов 'i' и 'j'
										** которые укажут нам на начало и конец куска строки, дубликат
										** которого мы хотим сделать */
{
	char	*word;						/* Обьявляем указатель для хранения адреса памяти выделенной под дубликат
										** куска строки содержащей слово */
	int		o;							/* Обьявляем переменную под счетчик для перемещения по выделенной памяти */

	if ((word = (char *)malloc(sizeof(char) * (j - i))) == ((void *)0))/* Выделяем память под слово, сохраняем 
										** адресс выделеной памятии в указателе 'word' и проверяем прошло ли 
										** выделение памяти без ошибок */
		return ((void *)0);				/* Если были проблемы то завершаем функцию и возвращаем нулевой указатель */
	o = 0;								/* Инициализируем счетчик нулем чтобы начать копирование куска строки cодержащей
										** слово из 'str' в выделеную память начиная с нулевой ячейки выделенной памяти */
	while (i < j)						/* Запускаем цикл, который по одному символу скопирует кусок строки со словом 
										** из 'str', в выделеную нами память, с помощью переменной 'i', которая хранит
										** номер ячейки с символом где начинается слово, и с помощью переменной 'j', 
										** которая хранит номер ячейки, c символом, на котором заканчивается слово */
	{
		word[o] = str[i];				/* Копируем каждый символ слова в выделеную память */
		i++;							/* Увеличиваем счетчик для перехода к след ячейке с символом который нужно скопировать */
		o++;							/* Увеличиваем счетчик для перехода к след ячейке, в которую мы скопируем символ */
	}
	word[o] = '\0';						/* Записываем в конец строки символ завершающего нуля */
	return (word);						/* Завершаем функцию и возвращаем ноль */
}

/* ************************************************************************** */
/* ************************************************************************** */

char		**ft_split(char *str, char *charset)/* Функция разбирает строку символов на отдельные слова 
										** создавая для них отдельные массивы символов, записывает адреса 
										** созданных массивов в массив указателлей на указатели и возвращает
										** этот адресс массива указателей на указатели */
{
	char	**arr;						/* Обьявляем указатель на указатель, в который мы сохраним адресс выделеной
										** памяти под адреса строк(массивы символов) */
	int		i;							/* Обьявляем переменную для подсчета и хранения индекса начала слова */
	int		j;							/* Обьявляем переменную для подсчета и хранения индекса конца слова */
	int		index;						/* Обьявляем переменную счетчик для перемещения по массиву со строками */
	int		words;						/* Обьявим переменную для хранения вычесленного количества строк */

	if ((words = ft_wordcount(str, charset)))/* Вызываем функцию по вычислению количества слов и записываем 
										** результат в переменную 'words'. Если слова есть то запускаем код внутри */
	{
		if (!str || (((arr = (char **)malloc(sizeof(char *) * (words + 1)))) == ((void *)0)))/* Выделяем память под
										** указатели(их будет столько же сколько слов нашла функция ft_wordcount в 
										** строке, плюс один указатель под завершающий - нулевой указатель). В эти 
										** указатели мы поместим адреса каждого добытого слова помещеных в строку
										** (массивов символов). И проверяем прошло ли выделение памяти без ошибок. */ 
			return ((void *)0);			/* Если были проблемы то завершаем функцию и возвращаем нулевой указатель */

		/* Если выше всё прошло удачно то мы переходим к созданию памяти для каждого слова */
		i = 0;							/* Инициализируем счетчик 'i' нулем чтобы начать поиск начала слова с 
										** нулевой ячейки строки 'str' */
		index = 0;						/* Инициализируем нулем счетчик для перемещения по ячейкам с указателями для адресов строк */
		while (index < words)			/* Этот цикл будет создавать память под слова и записывать найденые слова
										** в выделеную память, а адреса скопированных в новую память слов будут
										** сохранятся в массиве указателей */
		{
			while (ft_is_space(str[i], charset) && (str[i]))	/* Запускаем цикл который пропустит ту часть строки которая 
										** не является словом и найдет ячейку с символом с которой это слово начинается */
				i++;					/* Записываем в переменную 'i' колличество пройденных символов. Последнее значение 
										** этой переменной будет указывать на ячейку, в которой хранится первый символ слова */
			j = i;						/* Записываем в переменную 'j' найденый нами индекс первого символа найденого слова. */
			while (!(ft_is_space(str[j], charset)) && (str[j]))	/* Запускаем цикл, который посчитает где заканчивается найденое
										** нами слово */
				j++;					/* Записываем в переменную 'j' колличество пройденных символов. Последнее значение 
										** этой переменной будет указывать на первую ячейку после слова */
			arr[index] = create_word(str, i, j);/* Отправляем в функцию строку и диапазон символов 'i' и 'j' которые укажут
										** нам на начало и конец куска строки хранящей найденое слово.
										** Функция создаст дубликат найденого нами слова и вернет адресс созданного дубликата.
										** А мы сохраним адресс этого дубликата в одной из ячеек массива указателей,
										** создавая таким образом массив строк с найдеными словами */
			i = j + 1;					/* Перезаписываем переменную 'i' сохраняя в ней число указывающее на ячейку с символом, 
										** которая идет первой после найденого нами слова */
			index++;					/* Увеличиваем значение переменной 'index' для перехода к работе со след ячекой массива
										** указателей */
		}
	}
	else								/* Если функция 'ft_wordcount' не нашла в строке ни одного слова */
		arr = (char **)malloc(sizeof(char *));	/* То мы создадим массив указателей состоящий внутри из одного указателя и сохраняем
										** в нем нулевой адрес при выходе из условия 'else' */ 
	arr[i] = ((void *)0);				/* В конце массива указателей на указатели, хранящего адреса строк, добавляем нулевой адрес как 
										** символ конца этого массива указателей на указатели */
	return (arr);						/* Заавершаем функцию и возвращаем адресс массива с указателями на указатели(адреса массивов со
										** словами) */
}

/* ************************************************************************** */
/* ************************************************************************** */

int     main(void)						/* Основаная функция */
{
	char	**arr_str;					/* Обьявляем указатель на указатель, в который мы сохраним адресс массива с адресами строк */

	if ((arr_str = ft_split("_hello$my$##cool=frie nd!+", "! _=$+#@")) == ((void *)0)) /* Запускам функцию нахождения в строке 
										** отдельных слов и разбрасываем ихв отдельные строки */
		return (0);
	while (*arr_str != ((void *)0))		/* Проверяем есть ли по этому адресу строка. Если есть то спускаемся ниже и печатаем ее символы */
	{
		ft_putstr(*arr_str);			/* Печатаем текущую строку */
		ft_putchar('\n');				/* После, печатаем символ перехода на новую строку */
		arr_str++;						/* Переходим к след ячейке хранящей адрес другой строки */
	}
	return (0);							/* Если дошли до сюда значит основная функция завершается, возвращается ноль и программа завершается */ 
}