/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/10/08 18:29:05 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*         команда для компиляции и одновременного запуска                    */
/*                                                                            */
/*  gcc -Wall -Werror -Wextra test.c && chmod +x ./a.out && ./a.out           */
/* ************************************************************************** */

/* 
 * В примере в строке «Fuckin.Good.day.coming», с помощью функции ft_strstr, ищется
 * первое вхождение строки: «Good». Эта функця ищет нужную строку. и возвращает
 * адрес эдемента с которого начинаеться искомая строка если символы идентичны.
 * В тестовом файле консоль мы выведем номер первого элемента найденой строки
 * с помощью вычисления разности между двумя адресами.
 */

#include <unistd.h>

/* ************************************************************************** */
/* ************************************************************************** */


void	ft_putchar(char c)				/* функция вывода символа */
{
	write(1, &c, 1);
}

/* ************************************************************************** */
/* ************************************************************************** */

void	ft_putnbr(int nb)				/* функция печат целого числа */
{
	int	temp;
	int	size;

	size = 1;
	if (nb < 0)
	{
		ft_putchar('-');
		nb = -nb;
	}
	if (nb == -2147483648)
	{	
		ft_putchar('2');
		nb = 147483648;
	}
	temp = nb;
	while ((temp /= 10) > 0)
		size *= 10;
	temp = nb;
	while (size)
	{
		ft_putchar((char)((temp / size)) + 48);
		temp %= size;
		size /= 10;
	}
}

/* ************************************************************************** */
/* ************************************************************************** */

void	ft_putstr(char *str)			/* функция печати строки */
{
	int	i;

	i = 0;
	while (*(str + i))
		i++;
	write(1, str, i);
}

/* ************************************************************************** */
/* ************************************************************************** */

/* Функция которая ищет одну строку в другой строке и если находит полное совпадение то возвращает адресс первого элемента нужного нам совпадения */
char	*ft_strstr(char *str, char *to_find)/* Функция принимает адрес строки(массива символов) в которой будет идти поиск и адрес строки которую мы ищем */
{
	int	i;								/* обьявим счетчик i для строки(массива символов) str в которой мы ищем */
	int	j;								/* обьявим счетчик j для строки(массива символов) to_find которую мы ищем */

	i = 0;								/* Инициализируем счетчик i нулем чтобы начать с нулевой позиции строки(массива символов) str */
	if (to_find[0] == '\0')				/* Если строка to_find пуста */
		return (str);					/* то возвращаем адрес строки str. */
	while (str[i])						/* Если строка(массив символов) to_find не пуста то запускаем цикл который будет пройдется по каждой ячейке массива str.
										** пока не дойдет до конца строки(массива символов) str (точнее не встретится ячейка с символом конца строки '\0') */
	{
		j = 0;							/* Инициализируем счетчик j нулем чтобы начать с нулевой позиции строки(массива символов) to_find */				
		while (str[i + j] == to_find[j])/* Если в строке str встретится такой же символ как и нулевой символ в строке to_find */
		{
			if (to_find[j + 1] == '\0')	/* то запускаем цикл который будет проверять не является ли след ячейка строки to_find концом */
				return (str + i);		/* если ячейка является концом то завершаем функцию и возвращаем адресс ячейки первого совпадения */
			j++;						/* Если ячейка не является концом то проверяем есть ли дальше в str такие же символы как и в to_find. 
										** Увеличиваем счетчик j указывая на след ячейку массива str и след ячейку массива to_find и проверяем их */
		}
										/* Если были совпадения но они оказались не полными, а строка в котрой мы ищем все еще не кончилась то 
										** мы возвращаем счетчик j к нулю. */
		i++;							/* И переходим к следующей ячейке массива str пока не найдем полное совпадение или не дойдем до конца строки */
	}
	return ((void *)0);					/* Если мы дошли до сюда значит массив str закончился и мы не нашли совпадений. Завершаем функцию и возвращаем нуль */
}

/* ************************************************************************** */
/* ************************************************************************** */

int 	main(void)
{
	char	r[] = {"Fuckin.Good.day.coming"};
	char	*p;


	p = ft_strstr(r, "Good"); 	/* Вызываем функцию которая ищет одну строку в другой строке и если находит полное 
								** совпадение то возвращает адресс первого элемента нужного нам совпадения.
								** Написать строку в двойных кавычка в аргументах где ожидается адресс массива
								** тоже можно!
								** Всё потому что перед передачей строки в функцию компилятор выделяет для нее 
								** память и уже сам меняет саму эту строку на адрес который хранит строку "Good"  */
	if ( p == ((void *)0))
    	ft_putstr("Строка не найдена\n");
	else
    {
		ft_putstr("Искомая строка начинается с символа: ");
		ft_putnbr(p - r + 1);	/* Так вычислем позицию первого элемента найденной строки. */
		ft_putchar('\n');
	}
	return (0);
}

